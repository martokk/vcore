# vCore Services & Business Logic

## Context
- When implementing business logic and service functions
- When creating reusable service modules
- When separating concerns between API, business logic, and data access

## Requirements
- Place business logic in service functions, not endpoints
- Use proper error handling and logging
- Implement async/await patterns where appropriate
- Use dependency injection for database sessions
- Create stateless service functions
- Use proper type hints and documentation

## Examples

<example>
# Good: Proper service implementation
from typing import Any
from sqlmodel import Session
from app import logger
from vcore.backend import crud, models

async def process_user_data(
    db: Session, 
    user_id: str, 
    data: dict[str, Any]
) -> dict[str, Any]:
    """Process user data with business logic."""
    try:
        user = await crud.user.get(db, id=user_id)
        # Business logic here
        result = {"success": True, "processed": data}
        logger.info(f"Processed data for user {user_id}")
        return result
    except Exception as e:
        logger.error(f"Error processing user data: {e}")
        return {"success": False, "error": str(e)}
</example>

<example type="invalid">
# Bad: Business logic in endpoint
@router.post("/process")
async def process_endpoint(data: dict):
    # Business logic mixed with endpoint logic
    user = db.query(User).first()  # Direct DB access
    # Complex processing here...
</example>

## Critical Rules
- ALWAYS place business logic in service functions
- ALWAYS use proper error handling and logging
- ALWAYS use async/await for database operations
- ALWAYS return structured results with success/error indicators
- NEVER mix business logic directly in API endpoints