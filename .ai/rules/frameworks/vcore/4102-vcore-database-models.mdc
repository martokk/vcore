---
description: Structure SQLModel models when creating database schemas to follow vCore validation patterns
globs: **/models/**/*.py
alwaysApply: false
---

# vCore Database Models

## Context

- When creating or modifying database models in your vCore-based application
- When implementing data validation and serialization using vCore patterns
- When working with SQLModel table definitions in your app

## Requirements

- Create separate Base, Create, Update, and Read models following vCore patterns
- Use proper Field definitions with appropriate constraints
- Implement model_validator for pre-validation logic
- Use Enums for status and type fields
- Include proper JSON field handling for metadata
- Use UUID primary keys with proper generation

## Examples

<example>
# Good: Proper vCore model structure in your app
# app/models/item.py
from sqlmodel import Field, SQLModel
from enum import Enum
from uuid import UUID, uuid4

class ItemStatus(str, Enum):
    active = "active"
    inactive = "inactive"

class ItemBase(SQLModel):
    id: UUID = Field(default_factory=uuid4, primary_key=True)
    name: str = Field(index=True)
    status: ItemStatus = Field(default=ItemStatus.active)

class Item(ItemBase, table=True):
    pass

class ItemCreate(ItemBase):
    pass

class ItemUpdate(SQLModel):
    name: str | None = None
    status: ItemStatus | None = None
</example>

<example type="invalid">
# Bad: Single model class without proper separation
class Item(SQLModel, table=True):
    name: str  # Missing validation, constraints
    status: str  # Should use Enum
</example>

## Critical Rules

- ALWAYS create Base, Create, Update, Read model variants following vCore patterns
- ALWAYS use Enums for status and type fields
- ALWAYS use UUID primary keys with uuid4 factory
- ALWAYS include proper Field constraints and indexes
- NEVER use raw string types for constrained fields
